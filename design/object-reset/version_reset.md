# Object Version Reset

## Object Prune
- [Object Prune Design](prune.md)

## Solution Categories

### Note about existing manifests
- Storage Manifest (manifest.xml)
  - contains information about all versions
  - is the only cloud storage file that is actively re-written during the life of a Merritt object
  - is difficult to modify correctly since the entire object history is captured
- Ingest Manifest (generated by storage)
  - This is easy to modify
  - This is suitable to use for purposes of creating a new version or a new object
  - This is not suitable for re-writing history

### Alter Object Composition 

#### Option 1: Re-write versions in place; Purge files while rewriting; No provenance for changes
  - This is David's changeToken proposal
  - PRO:
    - aligns with current architecture; minimal changes required
  - CON:
    - this is a one-off solution
    - no provenance recording ther change

#### Option 2: Re-ingest content as new object (new ark) - no local id; Delete old object
  - Note: this was used for the Dash --> Dryad migration.  The owner id changed creating a new localid. 
  - PRO: uses existing functionality
  - CON: requires a new ark, doesn't work if localid is present; history is lost once old object is deleted

#### Option 3: Re-ingest content as new object (new ark) - remap local id; Delete old object
  - New functionality is needed to re-map an existing localid to a new ark 
  - PRO: minimal changes
  - CON: requires a new ark; history is lost once old object is deleted

#### Option 4: Rebuild object from storage manifest (new object_id, same ark); Purge orphaned files
  - PRO: could save the storage manifest before and after as a provenance change; opportunity to review changes beforee applying
  - CON: does not facilitate renames 

#### Option 5: Collapse History and Reset object to V1 (same ark); Purge orphaned files; History is lost
  - PRO:
    - may be easy to implement the cleanup logic, ark is retained
    - this could be a suitable solution to offer to depositors to initiate
  - CON:
    - history is lost, no provenance of change, no opportunity to preview 

#### Option 6: Collapse History and Reset object to new version (same ark); Purge orphaned files; History is documented but inaccessible
  - Introduce the concept of a "stubbed" version in manifest.xml to retain history
  - PRO:
    - ark is retained, histoy is kept, need way to retain old history without items in cloud storage
  - CON:
    - may complicate replic logic
    - how would the depositor visualize the stubbed history?
    - what history would exist in the inventory database?   

#### ~Option 7: Tombstone files in cloud storage to convey key deletions/key renames; History is documented but inaccessible~
  - PRO:
    - change history could be reassembled by referencing 0 byte tombstones; changes are first applied to cloud storage
  - CON:
    - David and Terry could not identify a benefit to justify this complexity
    - Tombostone files would complicate scan resolution issues

#### Option 8: Repair transactions: apply file delete and file replace transactions (conveyed in json) to an existing object to clean up he object
  - This solution might introduce the concept of a stubbed file in the manifest.xml OR the file would be removed entirely. 
  - This is an attempt to define a generic solution around David's poposed changeToken fix
  - A flag could be included in transaction to allow/disallow the complete deletion of all files with identical checksum values

#### Option 9: Use existing tools to make current version "correct"; Apply a "PRUNE" transaction to purge files that are not in the current version of the object.
  - PRO:
    - leverages existing tools
    - depositor can preview purge candidates in the Merritt UI (and in an enhanced API)
    - depositor initiates the PRUNE
    - provenance can be recorded when the PRUNE is applied
      - should we record a new version to save this provenance information?
  - CON:
    - fix is a 2 step process  
  - Process Description
    - Repair option 1 (for depositors)
      - use mrt-delete files to correct the current object
    - Repair option 2 (for depositors and Merritt Team) 
      - run a Merritt ADD using a storage-generated ingest manifest for reconstruction
        - generate the baseline manifest from the current version
        - if we expose the storage manifest paths as an input format, what restrictions do we need to set on the use of these patterns?  Or, should the use of these paths be a privileged operation?
        - question - can the manifest be modified so that a rename effectively takes place?
    - Repair option 3 (for Merritt Team) 
      - run a Merritt ADD using a storage-generated ingest manifest for reconstruction
        - generate the baseline manifest from ALL versions
        - this would allow versioning mistakes to be created
    - Submit the Repair manifest as a Merritt ADD
    - Review the correction in the Merritt UI
      - The Merritt Object API could add a JSON array of "prune candidates" from prior versions
    - Apply a Merritt PRUNE transaction
      - Submit this through ingest with no payload
    - Prune options
      - prune any file key that has not been pulled forward to the current version
      - prune any file key that has not been pulled forward to the current version AND that has a duplicate checksum on a different key
    - Storage will
      - delete prune-able keys from primary storage
      - remove pruned keys from the storage manifest (or mark them as pruned)
      - trigger an inventory rebuild
      - trigger a re-replication of the entire object
  - Other Notes
    - The current billing process does not account for content deletion.  If a motivation for fixing content is to reduce cost, we will need to add features to decrement billing numbers
      - tombstone deleted file data to a new database table
      - run a monthy reconciliation process (as needed by collection?) to account for content removal
    - Consider an API feature that would allow a user identify content that could be pruned
    - Create a report to total prune-able counts at a collection level   

### Alter Object Hierarchy
- Change Owner
  - The latest mrt-owner.txt file will determine ownership for ALL versions of the object
  - Local id collions might make this impossible
- Change collection  
  - The latest mrt-membership.txt file will determine membership for ALL versions of the object
  - Collection changes could be incompatible with the primary storage node/secondary nodes for a collection


### Provenance Options
- Create a mrt-repair.txt file
  - Embed before and after versions of the storage manifest
  - Include date/time of operation
  - Include explanation of fix 

